<!DOCTYPE html>
<html lang="en">
<head>
      <meta charset="utf-8">
       <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <script type="text/javascript" src="jquery-2.1.4.min.js"></script>
      <script src="raphael-min.js"></script>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css" integrity="sha512-dTfge/zgoMYpP7QbHy4gWMEGsbsdZeCXz7irItjcC3sPUFtf0kuFbDz/ixG7ArTxmDjLXDmezHubeNikyKGVyQ==" crossorigin="anonymous">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.3.5/flatly/bootstrap.min.css" crossorigin="anonymous">
      
      <style>

      </style>


      <script>


       $(document).ready(function() {
          drawPlot();
      });

       bucketSize = 0;
       buckets = [];
       

       function Bucket(x, y, color, xStart, xEnd, yEnd) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.xStart = xStart;
        this.xEnd = xEnd;
        this.yEnd = yEnd;
       }

       function drawPlot() {
            // This is the base paper. Width will be 1000 px and Height will be 3000 px
            paper = Raphael(document.getElementById('canvas'), '85%','50%');

            paper.setViewBox(0,0, 700, 2500, true);


            var colors = ['#8E44AD', '#446Cb3', '#81cfe0', '#2C3E50', '#22A7F0', '#67809F', '#26A65B'];

            for (var i = 1; i < 1000; i++) {



              var color = Math.round(6 * Math.random());

              var x = Math.round(1200 * Math.random())  + 75;

              var y = Math.round(300 * Math.random()) + 100;

              var circle = paper.circle(x,y, 2).attr({'fill':colors[color], 'stroke-opacity' : '0'});
              circle.id = i;
              circle.name = colors[color];

              circle.data("originX", x);
              circle.data("originY", y);

              var check = true;
              for (var j = 0; j < buckets.length; j++) {
                if (buckets[j].color == colors[color]) {
                  check = false;
                }
              }

              if (check) {
                var k = new Bucket(0,850, colors[color], 0, 0, 1000);
                buckets.push(k);
              }


            }

            bucketSize = buckets.length;

            bucketPlacement(bucketSize);



          
      }


      $(window).scroll(function (event) {

      var scroll = $(window).scrollTop();
      // scroll is pixel offset from top

      // we want scroll to scale to screen height  : less height = more scroll

      scroll = scroll / (($(window).height())/700);

      scroll = scroll / (($(window).width()) / 1300);

      console.log("Scroll is: " + scroll);
      // Do something



        if (scroll > 200 && scroll < 800) {


          //console.log("Bucket size is : " + bucketSize);

          bucketPlacement(bucketSize);

          paper.forEach(function (el) {

          console.log("The id is : " + el.id);
          var tString = createBarGraph(el, scroll);

          el.transform(tString);

          //console.log(tString);
          
          });



        } else if (scroll > 800 && scroll < 1200) {

          bucketPlacement(bucketSize);

          paper.forEach(function (el) {

          var mString = createBarGraph(el, 800);
          el.transform(mString);

          });
        
        }
      });

      function updateBarGraph(el) {

        for (var j = 0; j < buckets.length; j++) {

          var endX = buckets[j].x;
          var endY = buckets[j].yEnd;

          buckets[j].x +=8;


          var retString = "T" + endX +"," + endY;

          if (buckets[j].x >= buckets[j].xEnd) {
                console.log("We are reverting the buckets start");
                buckets[j].x = buckets[j].xStart;
                buckets[j].yEnd -= 8;

          }

          return retString;

        }






      }
      function createBarGraph(el, scroll) {

        console.log("We have entered the createbarGraph funciton");

          //console.log("X is: " + buckets[i].x);
          //console.log(buckets[i].color);
          for (var j = 0; j < buckets.length; j++) {
            if (buckets[j].color == el.name) {
              //console.log("The x value is: " + el.attr("x"));
              var originX = el.data("originX");
              var originY = el.data("originY");

              //console.log("Origins" + originX);


              var scrollPercentage = (scroll-200) / 600;
              

              var endX = buckets[j].x;
              var endY = buckets[j].yEnd;

              //console.log("Ends" + endY);

              //console.log("ScrollPercentage" + scrollPercentage);

              var currentX = (endX - originX) * scrollPercentage;

              var currentY = (endY - originY) * scrollPercentage;
              // we have a start X and Y --> we need to store this

              console.log("Buckets[j] x is now : " + buckets[j].x);

              buckets[j]["x"] += 10;
              console.log("Buckets[j] x is now : " + buckets[j].x);
             


              if (currentX < buckets[j].xStart) {


              var retString = "T" + currentX +"," + currentY;



              if (buckets[j].x >= buckets[j].xEnd) {
                console.log("We are reverting the buckets start");
                buckets[j].x = buckets[j].xStart;
                buckets[j].yEnd -= 10;

              }

              return retString;

            } else {
              return "";
            }
            }
          }
        




      }

      function bucketPlacement(numBuckets) {


        var bucketLength = (700 / numBuckets);

        bucketLength = bucketLength - 10;

        //console.log("Bucket length is : " + bucketLength);

        var startOfNewBucket = 10;

        var padding = 10;

        for (var i = 0; i < numBuckets; i++) {

          // start and end point of path

          // y is constant
          // x is variable based on both padding & size of bucket

          var endOfBucket = startOfNewBucket+bucketLength;

          //var pathName = "M" + startOfNewBucket + ",850 L" + endOfBucket + ", 850";

          //var bucketBase = paper.path(pathName);

          buckets[i].x = startOfNewBucket;
          buckets[i].xStart = startOfNewBucket;
          buckets[i].xEnd = startOfNewBucket + bucketLength;
          buckets[i].yEnd = 1000;
          startOfNewBucket += (bucketLength + padding);

        }



      }




       </script>
 </head>
 <body bgcolor="f7f7f7">
     <div id="canvas" style="padding-left:12%; height:500%" > </div>

</body>
</html>
